### 三、数据结构

#### 1.常用数据结构简介
线性表
基本操作：

创建表
求表长度
查找元素
输入元素
删除元素
便利元素
顺序表
结构特点：

采用一组地址连续的存储单元来存储数据；
表的存储容量长度不易改变；
方便随机查找；
适用于频繁访问元素的应用；
不适用于频繁增删元素的应用。
单链表
结构特点：

采用指针链接一系列存储单元来存储数据；
动态分配存储空间；
插入和删除元素的效率很高
查找元素的效率较低。
循环链表
结构特点：

所有元素一次连接，尾部元素连接到首部元素
适用于环形结构处理场合
便于特定步长便利循环表元素
双向循环链表
结构特点：

每个元素拥有指向前后继的指针。
便于元素的逆向查找和遍历。
同时具备循环链表的所有优点。
静态链表
结构特点：

用数组空间建立一个类似链表的逻辑结构，为数据元素增加一个标号成员来模拟链表元素的next指针。
个方面性能与链表类似，插入、删除开销小，查找开销大。
一次性分配大块空间，当链表动态分配节点时，只用从预先申请的空间中取一个节点即可，避免普遍链表频繁申请及释放内存时产生的开销。
静态分配的大块空间可以被多个静态链表所共享，比静态分配内存的顺序表更加节约内存。
栈
基本操作：

创建栈
入栈操作
出栈操作
查询栈的长度
判断栈是否为空
遍历栈
情况栈
销毁栈
顺序栈
结构特点：

采用一组地址连续的存储单元来存储数据
顺序栈的存储容量不易改变
适用于后进先出的应用环境
链栈
结构特点:

采用不连续的存储单元来存储数据
链栈的存储空间灵活
适用于特定的后进先出应用环境
队列
基本操作：

创建队列
入队操作
出队操作
查询队列长度
判断队列是否为空
便利队列
清空队列
销毁队列
顺序队列
结构特点：

队列是一种先进选出的线性表，允许一端进行删除，另一端进行插入。

采用一组地址连续的存储单元来存储数据。
顺序队列的容量不容易改变
适于特定的先进先出类应用环境
链队列
结构特点:

采用不连续的存储单元进行存储数据
链队列的存储容量较为灵活
适应特定的先进先出的应用环境
循环队列
结构特点:

在队列的顺序存储结构中，除了用一组地址连续的存储单元依次存放从头到尾的元素之外，还需要设置两个指针域front和rear分别指向队列的队头和队尾元素位置。 
假设顺序队列的长度为N，当队尾插入N个元素后，队头一次删除N个元素后，队列中元素的个数为0，队列为空，但是由于顺序队列的性质，此队列将无法继续使用，那么循环队列就是试图将这些空间利用起来，方式就是将顺序队列造成一个环的空间。循环队列的空和满的状态都存在 front = rear。 
判断队列是空还是满的方法。

设置另一个位置标记区别空和满。
少用一个存储空间，约定front = rear.next 即为满。
串
基本操作：

串的创建和存储
串的复制
求串的长度
串的比较
求子串
串的连接
串的定长存储
定长顺序存储结构特点：

采用一组地址连续的存储单元来存储数据
串的存储容量长度不易改变
适用于串的长度固定，或串的长度较小，或串的长度变化较小的应用
不适用与串的长度变化较大的应用
串的堆分配存储
堆分配存储：

采用堆分配存储结构动态的存储数据
串的存储容量长度可以通过动态分配函数malloc（）和free（）改变，不会浪费内存，也不会出现串移除的情况。
堆分配顺序存储结构对串的处理方便，操作中对串长度没有任何限制
串的块链存储
分块链表存储：

采用若干个大小相等的链表块来存取数据
结点的数据根据串的大小来决定
串长不一定是结点的整数倍，链表的最后一个结点不一定被填满
适用于串长较大的应用
串值得链式存储结构占用存储量大且操作复杂
树
基本操作：

创建树
取根结点
取双亲结点值
求树的深度
插入子树
删除子树
求某结点长子
求某结点下一个兄弟
判断树是否为空
按层便利
替换结点中的值
销毁树
树的双亲表示法
结构特点：

将树在顺序存储的基础上加上双亲域。

采用一组地址连续的存储单元来存储数据
求结点的孩子需要便遍历整个结构
树的孩子兄弟表示法
树的孩子兄弟表示法，又称为树的二叉链表存储或二叉树表示法，指将树按照左孩子右兄弟的方式进行存储，结点的左指针指向孩子结点，右指针指向下一个兄弟结点。

二叉树
二叉树是一种特殊的树型结构，特点是每个结点的孩子结点树的度不超过2，并且二叉树的子树有左右之分，顺序不能颠倒。

基本操作:

创建二叉树
取根结点值
取双亲结点值
求二叉树深度
插入子树
删除子树
求某结点左、右孩子
求某结点左、右兄弟
判断树是否为空
先序、中序、后序、层序遍历
替换树种的结点值
销毁二叉树
二叉树的顺序存储
结构特点：

利用一组连续的存储单元依次自上而下，从左到右存储完全二叉树上的结点，存储过程中，将完全二叉树的结点编号为i的元素存储在如上定义的一维数组的下标为i-1的分量中。

若二叉树不是完全二叉树，那么存储二叉树时要考虑到结点位置的唯一性和准确性，将非完全二叉树作为完全二叉树来进行存储。对空结点，用0表示。

二叉树的链式存储
结构特点：

利用指针域来指向特点的结点。 
一般来讲，表示二叉树的链表中的结点至少包含3个域：数据域和左指针、右指针域。数据域用来存放该结点的数据，左右指针分别指向该结点的左孩子和右孩子。 
有时为方便查找双亲域，还添加一个指向双亲的指针域。 
利用以上两种结点构成的二叉树的存储结构分别称为二叉链表树和三叉链表树。

线索二叉树
结构特点：

依遍历规则把每个结点对应的前驱和后继线索预存起来，这叫做“线索化”。 
线索二叉树是在二叉链表作为基础的同时，增加两个标志域：Ltag和RLtag。 
tag = 0 时 child 指向孩子。 
tag = 1 时 child 指向线索。

线索化过程就是在遍历过程中修改空指针的过程。 
将空的lchild改为节点的直接前驱。 
将空的rchild改为结点的直接后继。

图
基本操作:

创建图
销魂图
查询顶点值
查询顶点序号
插入顶点
删除顶点
修改顶点值
增加弧
删除弧
深度优先遍历
广度优先遍历
图的存在形式：

有向图
有向网
无向图
无向网
图结构的表示方法

邻接矩阵
邻接表
十字链表
邻接多重表
图的邻接矩阵表示
图的邻接矩阵表示特点：

采用一维数组存储图的顶点信息
采用二维数组构件邻接矩阵，存储图（网）的弧（边）信息。
采用实现图的各种操作（求度、查询顶点、查询弧等）
存储空间静态申请，不便于扩展顶点数量
空间利用率低，对于稀疏图而言严重浪费空间。
图的邻接表表示
邻接表表示特点：

采用链表存储每个顶点的邻接信息（弧信息）
存储空间动态申请，便于扩展顶点数量。
空间利用率较高，非常适合稀疏图
便于查询邻接顶点
统计有向图顶点的入度开销庞大，针对有向图可以构造逆邻接表
图的十字链表表示
十字链表表示特点：

针对弧结点，增加入弧链表结构和出弧链表结构
容易求得任意顶点的出度和入度，专用于有向图的操作
结构实现比较复杂
图的邻接多重表表示
邻接多重表表示特点：

每个边结点均被其两个依附顶点的边链表所共用。
容易判断顶点之间的关系，专用于无向图的操作
结构实现相对复杂;

**常用数据结构 · 数组(静态数组、动态数组)
线性表、链表(单向链表、双向链表、循环链表)
队列、栈、树(二叉树、查找树、平衡树、线索树、线索树、堆)
图等的定义、存储和操作 · Hash(存储地址计算，冲突处理)** 

#### 2.并发集合了解哪些？
并发集合： 
ConcurrentHashMap 
CopyOnWriteArrayList 
CopyOnWriteArraySet

同步集合： 
HashTable 
Vector 
同步集合器Collections.synchronizedList(list)、Collections.synchronizedSet(set)、Collections.synchronizedMap(map)

二者都支持线程安全，区别主要体现在实现线程安全的方式，因此在性能和可扩展性上有明显不同！！！ 
同步集合是把整个集合锁起来，所以性能较差； 
并发集合是通过锁剥离、COW等技术使得多个线程可以同时访问集合，所以性能很好。

**并发集合中的分类：**
阻塞集合：这种集合包括添加和删除数据的操作。如果操作不能立即进行，是因为集合已满或者为空，该程序将被阻塞，直到操作可以进行。 
非阻塞集合：这种集合也包括添加和删除数据的操作。如果操作不能立即进行，这个操作将返回null值或抛出异常，但该线程将不会阻塞。 

一些常用的并发类集合包括： 
- 非阻塞列表，使用ConcurrentLinkedDeque类。 
- 阻塞列表，使用LinkedBlockingDeque类。 
- 用在生产者与消费者数据的阻塞列表，使用LinkedTransferQueue类。 
- 使用优先级排序元素的阻塞列表，使用PriorityBlockingQueue类。 
- 存储延迟元素的阻塞列表，使用DelayQueue类。 
- 非阻塞可导航的map，使用ConcurrentSkipListMap类。 
- 随机数，使用ThreadLocalRandom类 
- 原子变量，使用AtomicLong和AtomicIntegerArray类

插个链接
[并发集合](http://blog.csdn.net/paincupid/article/details/52017292)
[并发集合2](http://www.importnew.com/24594.html)
#### 3.列举java的集合以及集合之间的继承关系
![集合类图](https://images2015.cnblogs.com/blog/1010726/201706/1010726-20170621004734695-988542448.png)
![集合类图2](https://images2015.cnblogs.com/blog/1010726/201706/1010726-20170621004756882-1379253225.gif)

#### 4.容器类介绍以及之间的区别（容器类估计很多人没听这个词，Java容器主要可以划分为4个部分：List列表、Set集合、Map映射、工具类（Iterator迭代器、Enumeration枚举类、Arrays和Collections），具体的可以看看这篇博文 [Java容器类](http://alexyyek.github.io/2015/04/06/Collection/)）
#### 5.List,Set,Map的区别
* List和Map的实现方式以及存储方式
* HashMap的实现原理
* HashMap数据结构？
* HashMap源码理解
* HashMap如何put数据（从HashMap源码角度讲解）？
#### HashMap怎么手写实现？
* ConcurrentHashMap的实现原理
* ArrayMap和HashMap的对比
* HashTable实现原理
* TreeMap具体实现
* HashMap和HashTable的区别
* HashMap与HashSet的区别
* HashSet与HashMap怎么判断集合元素重复？
* 集合Set实现Hash怎么防止碰撞
* ArrayList和LinkedList的区别，以及应用场景
* 数组和链表的区别
* 二叉树的深度优先遍历和广度优先遍历的具体实现
* 堆的结构
* 堆和树的区别
* 堆和栈在内存中的区别是什么(解答提示：可以从数据结构方面以及实际实现方面两个方面去回答)？
* 什么是深拷贝和浅拷贝
* 手写链表逆序代码
* 讲一下对树，B+树的理解
* 讲一下对图的理解
* 判断单链表成环与否？
* 链表翻转（即：翻转一个单项链表）
* 合并多个单有序链表（假设都是递增的）