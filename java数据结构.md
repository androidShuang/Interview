### 三、数据结构

#### 1.常用数据结构简介
线性表
基本操作：

创建表
求表长度
查找元素
输入元素
删除元素
便利元素
顺序表
结构特点：

采用一组地址连续的存储单元来存储数据；
表的存储容量长度不易改变；
方便随机查找；
适用于频繁访问元素的应用；
不适用于频繁增删元素的应用。
单链表
结构特点：

采用指针链接一系列存储单元来存储数据；
动态分配存储空间；
插入和删除元素的效率很高
查找元素的效率较低。
循环链表
结构特点：

所有元素一次连接，尾部元素连接到首部元素
适用于环形结构处理场合
便于特定步长便利循环表元素
双向循环链表
结构特点：

每个元素拥有指向前后继的指针。
便于元素的逆向查找和遍历。
同时具备循环链表的所有优点。
静态链表
结构特点：

用数组空间建立一个类似链表的逻辑结构，为数据元素增加一个标号成员来模拟链表元素的next指针。
个方面性能与链表类似，插入、删除开销小，查找开销大。
一次性分配大块空间，当链表动态分配节点时，只用从预先申请的空间中取一个节点即可，避免普遍链表频繁申请及释放内存时产生的开销。
静态分配的大块空间可以被多个静态链表所共享，比静态分配内存的顺序表更加节约内存。
栈
基本操作：

创建栈
入栈操作
出栈操作
查询栈的长度
判断栈是否为空
遍历栈
情况栈
销毁栈
顺序栈
结构特点：

采用一组地址连续的存储单元来存储数据
顺序栈的存储容量不易改变
适用于后进先出的应用环境
链栈
结构特点:

采用不连续的存储单元来存储数据
链栈的存储空间灵活
适用于特定的后进先出应用环境
队列
基本操作：

创建队列
入队操作
出队操作
查询队列长度
判断队列是否为空
便利队列
清空队列
销毁队列
顺序队列
结构特点：

队列是一种先进选出的线性表，允许一端进行删除，另一端进行插入。

采用一组地址连续的存储单元来存储数据。
顺序队列的容量不容易改变
适于特定的先进先出类应用环境
链队列
结构特点:

采用不连续的存储单元进行存储数据
链队列的存储容量较为灵活
适应特定的先进先出的应用环境
循环队列
结构特点:

在队列的顺序存储结构中，除了用一组地址连续的存储单元依次存放从头到尾的元素之外，还需要设置两个指针域front和rear分别指向队列的队头和队尾元素位置。 
假设顺序队列的长度为N，当队尾插入N个元素后，队头一次删除N个元素后，队列中元素的个数为0，队列为空，但是由于顺序队列的性质，此队列将无法继续使用，那么循环队列就是试图将这些空间利用起来，方式就是将顺序队列造成一个环的空间。循环队列的空和满的状态都存在 front = rear。 
判断队列是空还是满的方法。

设置另一个位置标记区别空和满。
少用一个存储空间，约定front = rear.next 即为满。
串
基本操作：

串的创建和存储
串的复制
求串的长度
串的比较
求子串
串的连接
串的定长存储
定长顺序存储结构特点：

采用一组地址连续的存储单元来存储数据
串的存储容量长度不易改变
适用于串的长度固定，或串的长度较小，或串的长度变化较小的应用
不适用与串的长度变化较大的应用
串的堆分配存储
堆分配存储：

采用堆分配存储结构动态的存储数据
串的存储容量长度可以通过动态分配函数malloc（）和free（）改变，不会浪费内存，也不会出现串移除的情况。
堆分配顺序存储结构对串的处理方便，操作中对串长度没有任何限制
串的块链存储
分块链表存储：

采用若干个大小相等的链表块来存取数据
结点的数据根据串的大小来决定
串长不一定是结点的整数倍，链表的最后一个结点不一定被填满
适用于串长较大的应用
串值得链式存储结构占用存储量大且操作复杂
树
基本操作：

创建树
取根结点
取双亲结点值
求树的深度
插入子树
删除子树
求某结点长子
求某结点下一个兄弟
判断树是否为空
按层便利
替换结点中的值
销毁树
树的双亲表示法
结构特点：

将树在顺序存储的基础上加上双亲域。

采用一组地址连续的存储单元来存储数据
求结点的孩子需要便遍历整个结构
树的孩子兄弟表示法
树的孩子兄弟表示法，又称为树的二叉链表存储或二叉树表示法，指将树按照左孩子右兄弟的方式进行存储，结点的左指针指向孩子结点，右指针指向下一个兄弟结点。

二叉树
二叉树是一种特殊的树型结构，特点是每个结点的孩子结点树的度不超过2，并且二叉树的子树有左右之分，顺序不能颠倒。

基本操作:

创建二叉树
取根结点值
取双亲结点值
求二叉树深度
插入子树
删除子树
求某结点左、右孩子
求某结点左、右兄弟
判断树是否为空
先序、中序、后序、层序遍历
替换树种的结点值
销毁二叉树
二叉树的顺序存储
结构特点：

利用一组连续的存储单元依次自上而下，从左到右存储完全二叉树上的结点，存储过程中，将完全二叉树的结点编号为i的元素存储在如上定义的一维数组的下标为i-1的分量中。

若二叉树不是完全二叉树，那么存储二叉树时要考虑到结点位置的唯一性和准确性，将非完全二叉树作为完全二叉树来进行存储。对空结点，用0表示。

二叉树的链式存储
结构特点：

利用指针域来指向特点的结点。 
一般来讲，表示二叉树的链表中的结点至少包含3个域：数据域和左指针、右指针域。数据域用来存放该结点的数据，左右指针分别指向该结点的左孩子和右孩子。 
有时为方便查找双亲域，还添加一个指向双亲的指针域。 
利用以上两种结点构成的二叉树的存储结构分别称为二叉链表树和三叉链表树。

线索二叉树
结构特点：

依遍历规则把每个结点对应的前驱和后继线索预存起来，这叫做“线索化”。 
线索二叉树是在二叉链表作为基础的同时，增加两个标志域：Ltag和RLtag。 
tag = 0 时 child 指向孩子。 
tag = 1 时 child 指向线索。

线索化过程就是在遍历过程中修改空指针的过程。 
将空的lchild改为节点的直接前驱。 
将空的rchild改为结点的直接后继。

图
基本操作:

创建图
销魂图
查询顶点值
查询顶点序号
插入顶点
删除顶点
修改顶点值
增加弧
删除弧
深度优先遍历
广度优先遍历
图的存在形式：

有向图
有向网
无向图
无向网
图结构的表示方法

邻接矩阵
邻接表
十字链表
邻接多重表
图的邻接矩阵表示
图的邻接矩阵表示特点：

采用一维数组存储图的顶点信息
采用二维数组构件邻接矩阵，存储图（网）的弧（边）信息。
采用实现图的各种操作（求度、查询顶点、查询弧等）
存储空间静态申请，不便于扩展顶点数量
空间利用率低，对于稀疏图而言严重浪费空间。
图的邻接表表示
邻接表表示特点：

采用链表存储每个顶点的邻接信息（弧信息）
存储空间动态申请，便于扩展顶点数量。
空间利用率较高，非常适合稀疏图
便于查询邻接顶点
统计有向图顶点的入度开销庞大，针对有向图可以构造逆邻接表
图的十字链表表示
十字链表表示特点：

针对弧结点，增加入弧链表结构和出弧链表结构
容易求得任意顶点的出度和入度，专用于有向图的操作
结构实现比较复杂
图的邻接多重表表示
邻接多重表表示特点：

每个边结点均被其两个依附顶点的边链表所共用。
容易判断顶点之间的关系，专用于无向图的操作
结构实现相对复杂;

**常用数据结构 · 数组(静态数组、动态数组)
线性表、链表(单向链表、双向链表、循环链表)
队列、栈、树(二叉树、查找树、平衡树、线索树、线索树、堆)
图等的定义、存储和操作 · Hash(存储地址计算，冲突处理)** 

#### 2.并发集合了解哪些？
并发集合： 
ConcurrentHashMap 
CopyOnWriteArrayList 
CopyOnWriteArraySet

同步集合： 
HashTable 
Vector 
同步集合器Collections.synchronizedList(list)、Collections.synchronizedSet(set)、Collections.synchronizedMap(map)

二者都支持线程安全，区别主要体现在实现线程安全的方式，因此在性能和可扩展性上有明显不同！！！ 
同步集合是把整个集合锁起来，所以性能较差； 
并发集合是通过锁剥离、COW等技术使得多个线程可以同时访问集合，所以性能很好。

**并发集合中的分类：**
阻塞集合：这种集合包括添加和删除数据的操作。如果操作不能立即进行，是因为集合已满或者为空，该程序将被阻塞，直到操作可以进行。 
非阻塞集合：这种集合也包括添加和删除数据的操作。如果操作不能立即进行，这个操作将返回null值或抛出异常，但该线程将不会阻塞。 

一些常用的并发类集合包括： 
- 非阻塞列表，使用ConcurrentLinkedDeque类。 
- 阻塞列表，使用LinkedBlockingDeque类。 
- 用在生产者与消费者数据的阻塞列表，使用LinkedTransferQueue类。 
- 使用优先级排序元素的阻塞列表，使用PriorityBlockingQueue类。 
- 存储延迟元素的阻塞列表，使用DelayQueue类。 
- 非阻塞可导航的map，使用ConcurrentSkipListMap类。 
- 随机数，使用ThreadLocalRandom类 
- 原子变量，使用AtomicLong和AtomicIntegerArray类

插个链接
[并发集合](http://blog.csdn.net/paincupid/article/details/52017292)
[并发集合2](http://www.importnew.com/24594.html)
#### 3.列举java的集合以及集合之间的继承关系
![集合类图](https://images2015.cnblogs.com/blog/1010726/201706/1010726-20170621004734695-988542448.png)
![集合类图2](https://images2015.cnblogs.com/blog/1010726/201706/1010726-20170621004756882-1379253225.gif)

#### 4.容器类介绍以及之间的区别（容器类估计很多人没听这个词，Java容器主要可以划分为4个部分：List列表、Set集合、Map映射、工具类（Iterator迭代器、Enumeration枚举类、Arrays和Collections），具体的可以看看这篇博文 [Java容器类](http://alexyyek.github.io/2015/04/06/Collection/)）
#### 5.List,Set,Map的区别

#### HashMap怎么手写实现？
#### HashMap与HashTable的区别?
与之相比HashTable是线程安全的，且不允许key、value是null。
HashTable默认容量是11。
HashTable是直接使用key的hashCode(key.hashCode())作为hash值，不像HashMap内部使用static final int hash(Object key)扰动函数对key的hashCode进行扰动后作为hash值。
HashTable取哈希桶下标是直接用模运算%.（因为其默认容量也不是2的n次方。所以也无法用位运算替代模运算）
扩容时，新容量是原来的2倍+1。int newCapacity = (oldCapacity << 1) + 1;
Hashtable是Dictionary的子类同时也实现了Map接口，HashMap是Map接口的一个实现类；

#### ConcurrentHashMap的实现原理
[讲的特别好](https://www.cnblogs.com/study-everyday/p/6430462.html)

#### ArrayMap和HashMap的对比
[arraymap与hashmap的对比](https://blog.csdn.net/qq_16318981/article/details/54632223)
#### HashTable实现原理
线程安全的，因为几乎所有方法都加了同步锁，
键值对不能为Null，
实现上跟hashmap没有太大区别。

#### TreeMap具体实现
* HashMap与HashSet的区别
HashSet就是基于HashMap实现的，像是HashMap的一个封装。

#### HashSet与HashMap怎么判断集合元素重复？
首先hashset是通过hashmap的Key唯一性来做的，然后hashmap是通过hashCode() 和 euqals();
```java
 if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    p = e;
```

#### 集合Set实现Hash怎么防止碰撞
通过Hash的一个静态方法。

#### ArrayList和LinkedList的区别，以及应用场景
  1. ArrayList是实现了基于动态数组的数据结构，而LinkedList是基于链表的数据结构；
  2. 对于随机访问get和set，ArrayList要优于LinkedList，因为LinkedList要移动指针；
  3. 对于添加和删除操作add和remove，一般大家都会说LinkedList要比ArrayList快，因为ArrayList要移动数据。但是实际情况并非这样，对于添加或删除，LinkedList和ArrayList并不能明确说明谁快谁慢，下面会详细分析。
  4. 由于LinkedList可以实现栈、队列以及双端队列等数据结构，所以当特定需要时候，使用LinkedList，当然咯，数据量小的时候，两者差不多，视具体情况去选择使用；当数据量大的时候，如果只需要在靠前的部分插入或删除数据，那也可以选用LinkedList，反之选择ArrayList反而效率更高。
  5. 影响插入效率的还有插入位置和数据量，当数据量很大的时候arraylist效率更高，但是顺序插入的话，linkedlist效率高。
  
#### 数组和链表的区别
* 二叉树的深度优先遍历和广度优先遍历的具体实现
* 堆的结构
* 堆和树的区别
* 堆和栈在内存中的区别是什么(解答提示：可以从数据结构方面以及实际实现方面两个方面去回答)？
* 什么是深拷贝和浅拷贝
* 手写链表逆序代码
* 讲一下对树，B+树的理解
* 讲一下对图的理解
* 判断单链表成环与否？
* 链表翻转（即：翻转一个单项链表）
* 合并多个单有序链表（假设都是递增的）

#### java可重入锁
前言
相信学过java的人都知道 synchronized 这个关键词，也知道它用于控制多线程对并发资源的安全访问，兴许，你还用过Lock相关的功能，但你可能从来没有想过java中的锁底层的机制是怎么实现的。如果真是这样，而且你有兴趣了解，今天我将带领你轻松的学习下java中非常重要，也非常基础的可重入锁-ReentrantLock的实现机制。

听故事把知识掌握了
在一个村子里面，有一口井水，水质非常的好，村民们都想打井里的水。这井只有一口，村里的人那么多，所以得出个打水的规则才行。村长绞尽脑汁，最终想出了一个比较合理的方案，咱们来仔细的看看聪明的村长大人的智慧。

井边安排一个看井人，维护打水的秩序。

打水时，以家庭为单位，哪个家庭任何人先到井边，就可以先打水，而且如果一个家庭占到了打水权，其家人这时候过来打水不用排队。而那些没有抢占到打水权的人，一个一个挨着在井边排成一队，先到的排在前面。打水示意图如下 ：
![打水](http://img.blog.csdn.net/20160828140050915)
打水示意图

是不是感觉很和谐，如果打水的人打完了，他会跟看井人报告，看井人会让第二个人接着打水。这样大家总都能够打到水。是不是看起来挺公平的，先到的人先打水，当然不是绝对公平的，自己看看下面这个场景 :
![打水2](http://img.blog.csdn.net/20160828140339416)
同家人一起打水

看着，一个有娃的父亲正在打水，他的娃也到井边了，所以女凭父贵直接排到最前面打水，羡煞旁人了。 
以上这个故事模型就是所谓的公平锁模型，当一个人想到井边打水，而现在打水的人又不是自家人，这时候就得乖乖在队列后面排队。

事情总不是那么一帆风顺的，总会有些人想走捷径，话说看井人年纪大了，有时候，眼力不是很好，这时候，人们开始打起了新主意。新来打水的人，他们看到有人排队打水的时候，他们不会那么乖巧的就排到最后面去排队，反之，他们会看看现在有没有人正在打水，如果有人在打水，没辄了，只好排到队列最后面，但如果这时候前面打水的人刚刚打完水，正在交接中，排在队头的人还没有完成交接工作，这时候，新来的人可以尝试抢打水权，如果抢到了，呵呵，其他人也只能睁一只眼闭一只眼，因为大家都默认这个规则了。这就是所谓的非公平锁模型。新来的人不一定总得乖乖排队，这也就造成了原来队列中排队的人可能要等很久很久。 


java可重入锁-ReentrantLock实现细节
ReentrantLock支持两种获取锁的方式，一种是公平模型，一种是非公平模型。在继续之前，咱们先把故事元素转换为程序元素。
![转换](http://img.blog.csdn.net/20160828140524370)
元素转换 


咱们先来说说公平锁模型：

初始化时， state=0，表示无人抢占了打水权。这时候，村民A来打水(A线程请求锁)，占了打水权，把state+1，如下所示：
![state](http://img.blog.csdn.net/20160828140603433)
线程A获取锁

线程A取得了锁，把 state原子性+1,这时候state被改为1，A线程继续执行其他任务，然后来了村民B也想打水（线程B请求锁），线程B无法获取锁，生成节点进行排队，如下图所示：
![state2](http://img.blog.csdn.net/20160828140648840)
线程B等待

初始化的时候，会生成一个空的头节点，然后才是B线程节点，这时候，如果线程A又请求锁，是否需要排队？答案当然是否定的，否则就直接死锁了。当A再次请求锁，就相当于是打水期间，同一家人也来打水了，是有特权的，这时候的状态如下图所示：
![sss](http://img.blog.csdn.net/20160828140726734)
可重入锁获取

到了这里，相信大家应该明白了什么是可重入锁了吧。就是一个线程在获取了锁之后，再次去获取了同一个锁，这时候仅仅是把状态值进行累加。如果线程A释放了一次锁，就成这样了：
![就成这样了](http://img.blog.csdn.net/20160828140803281)
线程A释放一次锁

仅仅是把状态值减了，只有线程A把此锁全部释放了，状态值减到0了，其他线程才有机会获取锁。当A把锁完全释放后，state恢复为0，然后会通知队列唤醒B线程节点，使B可以再次竞争锁。当然，如果B线程后面还有C线程，C线程继续休眠，除非B执行完了，通知了C线程。注意，当一个线程节点被唤醒然后取得了锁，对应节点会从队列中删除。 


非公平锁模型

如果你已经明白了前面讲的公平锁模型，那么非公平锁模型也就非常容易理解了。当线程A执行完之后，要唤醒线程B是需要时间的，而且线程B醒来后还要再次竞争锁，所以如果在切换过程当中，来了一个线程C，那么线程C是有可能获取到锁的，如果C获取到了锁，B就只能继续乖乖休眠了。这里就不再画图说明了。 


其它知识点
java5中添加了一个并发包， java.util.concurrent，里面提供了各种并发的工具类，通过此工具包，可以在java当中实现功能非常强大的多线程并发操作。对于每个java攻城狮，我觉得非常有必要了解这个包的功能。虽然做不到一步到位，但慢慢虚心学习，沉下心来，总能慢慢领悟到java多线程编程的精华。 

#### hashmap形成环形链表
[环形链表](https://blog.csdn.net/hhx0626/article/details/54024222)